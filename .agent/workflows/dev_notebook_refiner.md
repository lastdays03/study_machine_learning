---
description: Jupyter Notebook의 코드 품질, 문서화 수준, 실행 안정성을 표준화된 절차로 개선하는 워크플로우입니다.
---

# Notebook Refiner Workflow

이 워크플로우는 기존에 작성된 Jupyter Notebook을 **학습 자료 수준(Study Material Quality)**으로 다듬기 위해 설계되었습니다. 단순 코드 정리를 넘어, **"왜(Why)"**에 대한 설명과 **실행 안정성(Stability)**을 확보하는 데 초점을 맞춥니다.

### 1단계: 분석 및 구조 설계 (Analyze & Structure)
노트북의 전체적인 흐름을 파악하고 논리적인 구조를 잡습니다.

1.  **Flow Check**: 데이터 로드 → 전처리 → 모델링 → 평가 → 시각화의 흐름이 자연스러운가?
2.  **Dependency Check**:
    *   모든 `import` 문이 첫 번째 셀(또는 상단)에 모여 있는가?
    *   데이터 로딩이 불필요하게 반복되지 않는가?
3.  **Kernel Check**: 사용된 커널(`.venv` 등)과 라이브러리 버전이 명시되어 있는가?

### 2단계: 표준화 및 리팩토링 (Refactor)
코드를 깔끔하고 읽기 쉽게 다듬습니다. (기능 변경 없이 유지보수성 향상)

1.  **Variable Naming**:
    *   `df`, `data` 등 모호한 이름 대신 `titanic_df`, `X_train` 등 명확한 이름 사용.
    *   관례(Convention) 준수: `X` (대문자, 행렬), `y` (소문자, 벡터).
2.  **Cell Granularity**: 하나의 셀이 너무 많은 일을 하지 않도록 적절히 분리합니까?
3.  **Output Cleaning**: `fit()` 실행 시 나오는 불필요하고 긴 로그 메시지를 숨기거나 정리합니다.

### 3단계: 문서화 (Document)
이 코드를 처음 보는 사람도 이해할 수 있도록 친절한 설명을 추가합니다. **가장 중요한 단계입니다.**

1.  **Markdown Headers**: 각 섹션(Load, Split, Train 등)에 명확한 제목(`#`, `##`)을 붙입니다.
2.  **Context & Why**:
    *   단순히 "코드를 실행합니다"가 아니라, **"왜 이 함수를 쓰는지", "이 파라미터는 무슨 의미인지"**를 설명합니다.
    *   (예: "데이터 불균형을 해소하기 위해 `StratifiedKFold`를 사용합니다.")
3.  **Code Comments**: 코드 줄 단위의 핵심 로직에 주석(`#`)을 답니다.

### 4단계: 검증 (Verify)
수정된 노트북이 실제로 잘 돌아가는지 확인합니다.

1.  **Restart & Run All**: 커널을 재시작하고 처음부터 끝까지 에러 없이 실행되는지 확인합니다.
2.  **Result Update**: 실행 결과(그래프, 점수 등)가 마크다운 설명과 일치하는지 확인합니다.
3.  **Visual Check**: 그래프의 축 레이블(Label), 제목(Title), 범례(Legend)가 빠짐없이 있는지 확인합니다.

### 5단계: 인사이트 도출 (Insights)
실습을 통해 알게 된 점을 깊이 있게 정리합니다. 단순한 "실습 완료"가 아니라 **"무엇을 배웠는가"**를 남깁니다.

1.  **Key Takeaways**:
    *   데이터의 특징 (예: "특정 변수가 예측에 결정적이었다")
    *   모델 성능의 변화 (예: "스케일링 전후 정확도가 10% 상승했다")
2.  **Try More**:
    *   "하이퍼파라미터를 더 바꾸면 어떨까?"
    *   "다른 알고리즘을 쓰면 더 좋을까?" 와 같은 추가 실험 아이디어를 남깁니다.
